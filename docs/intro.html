<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Introduction to pushi</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Plushi</span> <span class="project-version">0.1.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="examples.html"><div class="inner"><span>Examples of Plushi Usage</span></div></a></li><li class="depth-1 "><a href="instructions.html"><div class="inner"><span>Push Instructions in Pushi</span></div></a></li><li class="depth-1  current"><a href="intro.html"><div class="inner"><span>Introduction to pushi</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>plushi</span></div></div></li><li class="depth-2 branch"><a href="plushi.atoms.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>atoms</span></div></a></li><li class="depth-2 branch"><a href="plushi.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="plushi.encode.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>encode</span></div></a></li><li class="depth-2"><a href="plushi.instruction.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>instruction</span></div></a></li><li class="depth-3"><a href="plushi.instruction.io.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>io</span></div></a></li><li class="depth-2 branch"><a href="plushi.interpreter.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>interpreter</span></div></a></li><li class="depth-2 branch"><a href="plushi.state.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>state</span></div></a></li><li class="depth-2"><a href="plushi.utils.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>utils</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#introduction-to-pushi" name="introduction-to-pushi"></a>Introduction to pushi</h1>
<p>Pushi is a standalone, language agnostic interpreter for the Push language capable of running push programs via a JSON/EDN interface.</p>
<p>Push is a programming language designed for AI systems to write software in. It has virtually no syntax and supports all common data types and can express a variety of control structures and data structures.</p>
<p>To read more about the push language, see the <a href="https://erp12.github.io/push-redux/">Push Redux</a>.</p>
<h2><a href="#push-programs-in-pushi" name="push-programs-in-pushi"></a>Push Programs in Pushi</h2>
<p>In pushi, a Push program is made up of three fields.</p>
<ol>
  <li>A serialized blog of push code in either JSON or EDN. This is described in  detail in the next section.</li>
  <li>The arity (number of inputs) to the push program.</li>
  <li>A list of data types the program should return.</li>
</ol>
<p>It is reasonable to think of a push program in pushi as a single function where the blob of push code is the body and the arity and return types make up the signature. This information give pushi everything it needs to run the program given any valid set of inputs.</p>
<h2><a href="#generating-serialized-push-code" name="generating-serialized-push-code"></a>Generating Serialized Push Code</h2>
<p>The main use case which pushi is designed to support is to be integrated with various artificial intelligence, machine learning, or search frameworks for the purpose of automatic programming. In order to acheive this, pushi must supply these frameworks with everything needed to generate valid Push programs which pushi is capable of executing.</p>
<p>As described in the <a href="https://erp12.github.io/push-redux/">Push-Redux</a>, Push programs are nested lists of “literals” and “instructions.”</p>
<p>A literal is roughly the Push equivalent of a primitive data type in most other languages. Literal values include integers, floats, strings, and booleans.</p>
<p>An instruction is a built in function or operation supported by the Push interpreter. Pushi has a set of supported instructions which is documented <a href="">in its own topic</a> however one can also retreive these instructions, including their signatures and docstrings, in code via the Pushi standalone.</p>
<blockquote>
  <p>Pushi does not currently support any form of runtime user defined instructions (UDI), although it is trivial to add your own instructions in the Pushi source code and build your own version of the standalone. If you feel your instructions are likely to be of any interest to other users, please consider <a href="">contributing them</a> to the pushi project on GitHub.</p>
</blockquote>
<p>Below is a snippet of python 3 code that shows how one might retreive the set of supported instructions in their own project.</p>
<pre><code class="py">import subprocess
import json
instructions = json.loads(subprocess.run(["java", "-jar" "pushi-0.1.0-standalone.jar",
                                          "--instruction-set",
                                          "--arity", 2,
                                          "--format" "json"],
                                         stdout=subprocess.PIPE).stdout)
</code></pre>
<p>The <code>-I</code> flag denotes that the standalone should return the set of supported instructions. The result will be a list of dictionaries. Each dictionary will define a single instruction. For example, below is the dictoinary for the <code>integer_add</code> instruction:</p>
<pre><code class="py">{
  'name': 'pushi:integer_add',
  'input-types': ['integer', 'integer'],
  'output-types': ['integer'],
  'docstring': 'Adds the top two integer stack values, and pushes the result.'
}
</code></pre>
<p>The <code>name</code> field is an identifier for the instruction. The <code>input-types</code> field denotes what data types, and how many of them, the instruction requires for input. In the <code>integer-add</code> example, we can see that the instruction requires 2 integer inputs. The <code>output-types</code> field denotes how many output values the instruction produces and each of their data types. The <code>docstring</code> values describes the behavior of the instruction for reference, and is not intended to be used by AI/ML systems.</p>
<h3><a href="#instructions-for-your-problem" name="instructions-for-your-problem"></a>Instructions For Your Problem</h3>
<p>It is rare that all instructions will be required for a given problem. For example, if you are attempting to produce a program that acts as a regression model with real-valued numeric inputs, you will not require the use of instructions that manipulate strings such as <code>string_split</code>. Given the instruction specs in the instruction set returned by pushi, it is trival to filter out instructions which are not needed. Below is a python example.</p>
<pre><code class="py">float_instructions = []
for i in instructions:
  if ("float" in i["input-types"]) or ("float" in i["output-types"]):
    float_instructions.append(i)
</code></pre>
<p>We commonly want to produce programs that accept some input values that impact program behavior. The Push programs we generate using pushi must include instructions which reference these input values. These instructions are called input instructions. To ensure the input instructions are included in the instruction set, we specify the <code>--arity</code> of the programs we will be generating when calling pushi with <code>--instruction-set</code>.</p>
<h3><a href="#using-instruction-set-to-create-programs" name="using-instruction-set-to-create-programs"></a>Using Instruction Set to Create Programs</h3>
<pre><code class="py">program_dict = {
    "code": [1.5, 2.8, float_instructions[3]["name"]],
    "arity": 2,
    "output-types": ["float"]
}
prog_result_json = subprocess.run(["lein", "run",
                                   "--run", json.dumps(program_dict),
                                   "--format", "json",
                                   "--inputs", "[0.123, 4.56]"],
                                  stdout=subprocess.PIPE).stdout
prog_result = json.loads(prog_result_json)
</code></pre></div></div></div></body></html>